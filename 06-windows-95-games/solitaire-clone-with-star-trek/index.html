<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Star Trek Solitaire - Windows 95 Edition</title>
  <script crossorigin src="https://unpkg.com/react@19/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@19/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            pixel: ['"Press Start 2P"', 'monospace'],
            win95: ['"Microsoft Sans Serif"', '"MS Sans Serif"', 'Arial', 'sans-serif'],
          }
        }
      }
    };
  </script>
  <style>
    body { margin: 0; background: #000; font-family: "Microsoft Sans Serif","MS Sans Serif",Arial,sans-serif; }
    .win95-raised { border-top:2px solid #fff; border-left:2px solid #fff; border-right:2px solid #808080; border-bottom:2px solid #808080; }
    .win95-sunken { border-top:2px solid #808080; border-left:2px solid #808080; border-right:2px solid #fff; border-bottom:2px solid #fff; }
    .win95-window { border-top:3px solid #dfdfdf; border-left:3px solid #dfdfdf; border-right:3px solid #404040; border-bottom:3px solid #404040; box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #000, 4px 4px 16px rgba(0,0,0,0.6); }
    .title-bar { background: linear-gradient(90deg, #000080, #1084d0); }
    .win95-btn { border-top:2px solid #fff; border-left:2px solid #fff; border-right:2px solid #404040; border-bottom:2px solid #404040; box-shadow: 1px 1px 0 #000; }
    .win95-btn:active { border-top:2px solid #404040; border-left:2px solid #404040; border-right:2px solid #fff; border-bottom:2px solid #fff; box-shadow:none; padding-top:1px; padding-left:1px; }
    .win95-btn:disabled { color: #808080; text-shadow: 1px 1px 0 #fff; }
    .card-shadow { box-shadow: 1px 1px 3px rgba(0,0,0,0.4); }
    .drag-card { box-shadow: 3px 3px 10px rgba(0,0,0,0.5); }
    @keyframes winPulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.02)} }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="typescript,react">
// ============================================================
// STAR TREK SOLITAIRE â€” Windows 95 Edition
// React 19, TypeScript, Tailwind CSS
// ============================================================

const { useState, useEffect, useRef, useCallback, memo } = React;

// ==================== TYPES ====================

type Suit = 'hearts' | 'diamonds' | 'clubs' | 'spades';
type PileType = 'stock' | 'waste' | 'tableau' | 'foundation';

interface Card {
  id: string;
  suit: Suit;
  rank: number;
  faceUp: boolean;
}

interface PileLocation {
  type: PileType;
  index: number;
  cardIndex: number;
}

interface GameState {
  stock: Card[];
  waste: Card[];
  tableau: Card[][];
  foundations: Card[][];
  score: number;
  moves: number;
}

// ==================== CONSTANTS ====================

const SUITS: Suit[] = ['clubs', 'diamonds', 'hearts', 'spades'];

const SUIT_SYMBOLS: Record<Suit, string> = {
  hearts: '\u2665', diamonds: '\u2666', clubs: '\u2663', spades: '\u2660',
};

const SUIT_COLORS: Record<Suit, string> = {
  hearts: '#dc2626', diamonds: '#dc2626', clubs: '#1a1a2e', spades: '#1a1a2e',
};

const RANK_LABELS: Record<number, string> = {
  1:'A', 2:'2', 3:'3', 4:'4', 5:'5', 6:'6', 7:'7',
  8:'8', 9:'9', 10:'10', 11:'J', 12:'Q', 13:'K',
};

const CARD_W = 80;
const CARD_H = 112;
const FDOWN_OFF = 18;
const FUP_OFF = 26;

// ==================== GAME LOGIC ====================

function isRed(suit: Suit): boolean {
  return suit === 'hearts' || suit === 'diamonds';
}

function createDeck(): Card[] {
  const deck: Card[] = [];
  for (const suit of SUITS) {
    for (let rank = 1; rank <= 13; rank++) {
      deck.push({ id: `${suit}-${rank}`, suit, rank, faceUp: false });
    }
  }
  return deck;
}

function shuffleDeck<T>(arr: T[]): T[] {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function dealNewGame(): GameState {
  const deck = shuffleDeck(createDeck());
  const tableau: Card[][] = [];
  let idx = 0;
  for (let col = 0; col < 7; col++) {
    tableau[col] = [];
    for (let row = 0; row <= col; row++) {
      tableau[col].push({ ...deck[idx++], faceUp: row === col });
    }
  }
  return {
    stock: deck.slice(idx),
    waste: [],
    tableau,
    foundations: [[], [], [], []],
    score: 0,
    moves: 0,
  };
}

function canPlaceOnTableau(card: Card, pile: Card[]): boolean {
  if (pile.length === 0) return card.rank === 13;
  const top = pile[pile.length - 1];
  return top.faceUp && top.rank === card.rank + 1 && isRed(card.suit) !== isRed(top.suit);
}

function canPlaceOnFoundation(card: Card, foundation: Card[]): boolean {
  if (foundation.length === 0) return card.rank === 1;
  const top = foundation[foundation.length - 1];
  return card.suit === top.suit && card.rank === top.rank + 1;
}

function isGameWon(state: GameState): boolean {
  return state.foundations.every(f => f.length === 13);
}

function suitToFoundationIndex(suit: Suit): number {
  return SUITS.indexOf(suit);
}

// ==================== STARFIELD ====================

function Starfield() {
  const ref = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = ref.current!;
    const ctx = canvas.getContext('2d')!;
    let animId = 0;

    const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
    resize();
    window.addEventListener('resize', resize);

    const stars = Array.from({ length: 140 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 1.5 + 0.5,
      brightness: Math.random() * 0.7 + 0.3,
      speed: Math.random() * 0.03 + 0.005,
      phase: Math.random() * Math.PI * 2,
    }));

    const animate = () => {
      ctx.fillStyle = '#000008';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (const s of stars) {
        s.phase += s.speed;
        s.x -= 0.03;
        s.y += 0.01;
        if (s.x < 0) s.x = canvas.width;
        if (s.y > canvas.height) s.y = 0;
        const alpha = s.brightness * (0.4 + 0.6 * ((Math.sin(s.phase) + 1) / 2));
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(200,220,255,${alpha})`;
        ctx.fill();
      }
      animId = requestAnimationFrame(animate);
    };
    animId = requestAnimationFrame(animate);
    return () => { cancelAnimationFrame(animId); window.removeEventListener('resize', resize); };
  }, []);

  return <canvas ref={ref} className="fixed inset-0 z-0" />;
}

// ==================== CARD COMPONENTS ====================

const CardFace = memo(({ card, dim }: { card: Card; dim?: boolean }) => {
  const color = SUIT_COLORS[card.suit];
  const sym = SUIT_SYMBOLS[card.suit];
  const label = RANK_LABELS[card.rank];
  return (
    <div
      className={`relative bg-white rounded-sm select-none card-shadow ${dim ? 'opacity-30' : ''}`}
      style={{ width: CARD_W, height: CARD_H, border: '1px solid #aaa' }}
    >
      <div className="absolute top-0.5 left-1.5 leading-tight" style={{ color, fontSize: 12, fontWeight: 'bold' }}>
        <div>{label}</div>
        <div style={{ marginTop: -2 }}>{sym}</div>
      </div>
      <div className="absolute inset-0 flex items-center justify-center" style={{ color }}>
        <span style={{ fontSize: 30 }}>{sym}</span>
      </div>
      <div className="absolute bottom-0.5 right-1.5 leading-tight rotate-180" style={{ color, fontSize: 12, fontWeight: 'bold' }}>
        <div>{label}</div>
        <div style={{ marginTop: -2 }}>{sym}</div>
      </div>
    </div>
  );
});

const CardBack = memo(() => (
  <div
    className="relative rounded-sm overflow-hidden select-none card-shadow"
    style={{
      width: CARD_W, height: CARD_H,
      background: 'linear-gradient(135deg, #0a1628 0%, #162d6a 50%, #0a1628 100%)',
      border: '2px solid #c8962c',
    }}
  >
    <div className="absolute inset-1.5 border border-yellow-700/40 rounded-sm" />
    <div className="absolute inset-0 flex items-center justify-center">
      <svg viewBox="0 0 60 72" style={{ width: 34, height: 40 }}>
        <path d="M30 6 L54 66 Q30 50 6 66 Z" fill="#c8962c" opacity="0.85" />
        <path d="M30 20 L44 58 Q30 48 16 58 Z" fill="#0d1b3e" opacity="0.5" />
      </svg>
    </div>
    <div className="absolute" style={{ top:8, left:10, width:2, height:2, background:'#c8962c', borderRadius:'50%', opacity:0.5 }} />
    <div className="absolute" style={{ top:14, right:12, width:1.5, height:1.5, background:'#c8962c', borderRadius:'50%', opacity:0.4 }} />
    <div className="absolute" style={{ bottom:10, left:14, width:1.5, height:1.5, background:'#c8962c', borderRadius:'50%', opacity:0.4 }} />
    <div className="absolute" style={{ bottom:16, right:10, width:2, height:2, background:'#c8962c', borderRadius:'50%', opacity:0.5 }} />
  </div>
));

const EmptySlot = memo(({ label, highlight }: { label?: string; highlight?: boolean }) => (
  <div
    className={`rounded-sm flex items-center justify-center select-none ${highlight ? 'ring-2 ring-yellow-400/60' : ''}`}
    style={{ width: CARD_W, height: CARD_H, border: '2px dashed rgba(255,255,255,0.15)', background: 'rgba(255,255,255,0.02)' }}
  >
    {label && <span className="text-2xl opacity-15 text-white">{label}</span>}
  </div>
));

// ==================== VICTORY CASCADE ====================

function VictoryCascade({ onNewGame }: { onNewGame: () => void }) {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current!;
    const ctx = canvas.getContext('2d')!;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    interface FlyingCard { x: number; y: number; vx: number; vy: number; suit: Suit; rank: number; }
    const cards: FlyingCard[] = [];
    let cardIdx = 0;
    let lastAdd = 0;

    const drawCard = (c: FlyingCard) => {
      ctx.fillStyle = '#fff';
      ctx.fillRect(c.x, c.y, 60, 84);
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.strokeRect(c.x, c.y, 60, 84);
      const color = isRed(c.suit) ? '#dc2626' : '#1a1a2e';
      ctx.fillStyle = color;
      ctx.font = 'bold 20px sans-serif';
      ctx.fillText(SUIT_SYMBOLS[c.suit], c.x + 20, c.y + 52);
      ctx.font = 'bold 11px sans-serif';
      ctx.fillText(RANK_LABELS[c.rank], c.x + 4, c.y + 16);
    };

    const animate = (time: number) => {
      if (time - lastAdd > 150 && cardIdx < 52) {
        const suitIdx = Math.floor(cardIdx / 13);
        cards.push({
          x: 380 + suitIdx * 92,
          y: 80,
          vx: (Math.random() - 0.5) * 10,
          vy: -Math.random() * 4 - 1,
          suit: SUITS[suitIdx],
          rank: (cardIdx % 13) + 1,
        });
        cardIdx++;
        lastAdd = time;
      }
      for (const c of cards) {
        c.vy += 0.5;
        c.x += c.vx;
        c.y += c.vy;
        if (c.y > canvas.height - 84) { c.vy *= -0.8; c.y = canvas.height - 84; }
        if (c.x < 0) { c.vx *= -0.9; c.x = 0; }
        if (c.x > canvas.width - 60) { c.vx *= -0.9; c.x = canvas.width - 60; }
        drawCard(c);
      }
      requestAnimationFrame(animate);
    };
    requestAnimationFrame(animate);
  }, []);

  return (
    <div className="fixed inset-0 z-50">
      <canvas ref={canvasRef} className="absolute inset-0" />
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="bg-[#c0c0c0] win95-window p-1 text-center" style={{ animation: 'winPulse 2s infinite' }}>
          <div className="title-bar text-white font-bold text-xs px-2 py-1 mb-1">Victory!</div>
          <div className="p-4">
            <p className="font-pixel text-sm mb-1" style={{ color: '#c8962c' }}>YOU WIN!</p>
            <p className="text-xs mb-3">All cards placed on foundations.</p>
            <button onClick={onNewGame} className="win95-btn bg-[#c0c0c0] px-4 py-1 text-xs cursor-pointer">
              New Game
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// ==================== MAIN APP ====================

function App() {
  const [game, setGame] = useState<GameState>(dealNewGame);
  const [history, setHistory] = useState<GameState[]>([]);
  const [timer, setTimer] = useState(0);
  const [timerActive, setTimerActive] = useState(false);
  const [gameWon, setGameWon] = useState(false);
  const [selected, setSelected] = useState<PileLocation | null>(null);

  // Drag refs
  const dragLayerRef = useRef<HTMLDivElement>(null);
  const dragInfoRef = useRef<{ cards: Card[]; source: PileLocation; offX: number; offY: number } | null>(null);
  const [dragCards, setDragCards] = useState<Card[]>([]);
  const [dragSource, setDragSource] = useState<PileLocation | null>(null);
  const pointerStartRef = useRef({ x: 0, y: 0 });
  const isDraggingRef = useRef(false);

  // Timer
  useEffect(() => {
    if (!timerActive || gameWon) return;
    const id = setInterval(() => setTimer(t => t + 1), 1000);
    return () => clearInterval(id);
  }, [timerActive, gameWon]);

  // Win check
  useEffect(() => {
    if (isGameWon(game) && !gameWon) setGameWon(true);
  }, [game]);

  const formatTime = (s: number) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;

  // === ACTIONS ===

  const saveAndApply = (newState: GameState) => {
    setHistory(h => [...h, structuredClone(game)]);
    setGame(newState);
    setSelected(null);
    if (!timerActive) setTimerActive(true);
  };

  const handleNewGame = () => {
    setGame(dealNewGame());
    setHistory([]);
    setTimer(0);
    setTimerActive(false);
    setGameWon(false);
    setSelected(null);
  };

  const handleUndo = () => {
    if (history.length === 0) return;
    setGame(history[history.length - 1]);
    setHistory(h => h.slice(0, -1));
    setSelected(null);
  };

  const handleDraw = () => {
    const s = structuredClone(game);
    if (s.stock.length === 0) {
      if (s.waste.length === 0) return;
      s.stock = s.waste.reverse().map(c => ({ ...c, faceUp: false }));
      s.waste = [];
      s.score = Math.max(0, s.score - 20);
    } else {
      const count = Math.min(3, s.stock.length);
      const drawn = s.stock.splice(-count);
      drawn.forEach(c => c.faceUp = true);
      s.waste.push(...drawn);
    }
    s.moves++;
    saveAndApply(s);
  };

  const tryMove = (src: PileLocation, tgtType: PileType, tgtIndex: number): boolean => {
    const s = structuredClone(game);
    let movingCards: Card[] = [];

    // Remove from source
    if (src.type === 'waste') {
      if (s.waste.length === 0) return false;
      movingCards = s.waste.splice(-1);
    } else if (src.type === 'tableau') {
      const pile = s.tableau[src.index];
      movingCards = pile.splice(src.cardIndex);
      if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
        pile[pile.length - 1].faceUp = true;
        s.score += 5;
      }
    } else if (src.type === 'foundation') {
      if (s.foundations[src.index].length === 0) return false;
      movingCards = s.foundations[src.index].splice(-1);
    }

    if (movingCards.length === 0) return false;

    // Place on target
    if (tgtType === 'tableau') {
      if (!canPlaceOnTableau(movingCards[0], s.tableau[tgtIndex])) return false;
      s.tableau[tgtIndex].push(...movingCards);
      if (src.type === 'waste') s.score += 5;
      else if (src.type === 'foundation') s.score -= 15;
    } else if (tgtType === 'foundation') {
      if (movingCards.length > 1) return false;
      if (!canPlaceOnFoundation(movingCards[0], s.foundations[tgtIndex])) return false;
      s.foundations[tgtIndex].push(movingCards[0]);
      s.score += 10;
    } else {
      return false;
    }

    s.score = Math.max(0, s.score);
    s.moves++;
    saveAndApply(s);
    return true;
  };

  const autoMoveToFoundation = (src: PileLocation, card: Card): boolean => {
    const fIdx = suitToFoundationIndex(card.suit);
    if (canPlaceOnFoundation(card, game.foundations[fIdx])) {
      return tryMove(src, 'foundation', fIdx);
    }
    return false;
  };

  // === CLICK / SELECT LOGIC ===

  const handleCardClick = (loc: PileLocation, card: Card) => {
    if (!card.faceUp) return;

    // If something is already selected, try to move it here
    if (selected) {
      if (selected.type === loc.type && selected.index === loc.index && selected.cardIndex === loc.cardIndex) {
        setSelected(null);
        return;
      }
      // Try to move selected to this pile
      if (loc.type === 'tableau') {
        if (tryMove(selected, 'tableau', loc.index)) return;
      }
      if (loc.type === 'foundation') {
        if (tryMove(selected, 'foundation', loc.index)) return;
      }
      setSelected(null);
      return;
    }

    // Select this card
    setSelected(loc);
  };

  const handleEmptyClick = (type: PileType, index: number) => {
    if (selected) {
      tryMove(selected, type, index);
      setSelected(null);
    }
  };

  const handleDoubleClick = (loc: PileLocation, card: Card) => {
    if (!card.faceUp) return;
    autoMoveToFoundation(loc, card);
  };

  // === DRAG AND DROP ===

  const handlePointerDown = (e: React.PointerEvent, loc: PileLocation, card: Card) => {
    if (!card.faceUp || e.button !== 0) return;
    e.preventDefault();
    pointerStartRef.current = { x: e.clientX, y: e.clientY };
    isDraggingRef.current = false;

    let cards: Card[] = [];
    if (loc.type === 'tableau') {
      cards = game.tableau[loc.index].slice(loc.cardIndex);
    } else if (loc.type === 'waste') {
      cards = [game.waste[game.waste.length - 1]];
    } else if (loc.type === 'foundation') {
      cards = [game.foundations[loc.index][game.foundations[loc.index].length - 1]];
    }

    const rect = (e.target as HTMLElement).closest('[data-card]')?.getBoundingClientRect();
    const offX = rect ? e.clientX - rect.left : 40;
    const offY = rect ? e.clientY - rect.top : 10;

    dragInfoRef.current = { cards, source: loc, offX, offY };

    const onMove = (ev: PointerEvent) => {
      const dx = ev.clientX - pointerStartRef.current.x;
      const dy = ev.clientY - pointerStartRef.current.y;
      if (!isDraggingRef.current && Math.sqrt(dx * dx + dy * dy) < 5) return;

      if (!isDraggingRef.current) {
        isDraggingRef.current = true;
        setDragCards(cards);
        setDragSource(loc);
      }

      if (dragLayerRef.current) {
        dragLayerRef.current.style.left = (ev.clientX - offX) + 'px';
        dragLayerRef.current.style.top = (ev.clientY - offY) + 'px';
      }
    };

    const onUp = (ev: PointerEvent) => {
      document.removeEventListener('pointermove', onMove);
      document.removeEventListener('pointerup', onUp);

      if (isDraggingRef.current && dragInfoRef.current) {
        // Find drop target
        const els = document.elementsFromPoint(ev.clientX, ev.clientY);
        const target = els.find(el => el instanceof HTMLElement && el.dataset.pileType) as HTMLElement | undefined;

        if (target) {
          const tType = target.dataset.pileType as PileType;
          const tIdx = parseInt(target.dataset.pileIndex || '0');
          tryMove(dragInfoRef.current.source, tType, tIdx);
        }
      }

      isDraggingRef.current = false;
      dragInfoRef.current = null;
      setDragCards([]);
      setDragSource(null);
    };

    document.addEventListener('pointermove', onMove);
    document.addEventListener('pointerup', onUp);
  };

  // Is a card part of the current drag?
  const isDraggedCard = (cardId: string) => dragCards.some(c => c.id === cardId);
  // Is a card the selected card?
  const isSelected = (loc: PileLocation) =>
    selected && selected.type === loc.type && selected.index === loc.index && selected.cardIndex === loc.cardIndex;

  // === RENDER HELPERS ===

  const renderCard = (card: Card, loc: PileLocation, style: React.CSSProperties = {}) => {
    const dragged = isDraggedCard(card.id);
    const sel = isSelected(loc);
    return (
      <div
        key={card.id}
        data-card={card.id}
        className={`absolute cursor-pointer ${sel ? 'ring-2 ring-yellow-400 ring-offset-1 rounded-sm z-10' : ''}`}
        style={{ ...style, opacity: dragged ? 0.3 : 1 }}
        onClick={(e) => { e.stopPropagation(); handleCardClick(loc, card); }}
        onDoubleClick={(e) => { e.stopPropagation(); handleDoubleClick(loc, card); }}
        onPointerDown={(e) => handlePointerDown(e, loc, card)}
      >
        {card.faceUp ? <CardFace card={card} /> : <CardBack />}
      </div>
    );
  };

  // Waste: show top 1-3 cards fanned
  const wasteVisible = game.waste.slice(-3);

  return (
    <>
      <Starfield />

      {/* Win95 Window */}
      <div className="fixed inset-0 z-10 flex items-start justify-center pt-4 pb-4 overflow-auto">
        <div className="bg-[#c0c0c0] win95-window p-[3px] select-none" style={{ minWidth: 700 }}>

          {/* Title Bar */}
          <div className="title-bar text-white flex items-center justify-between px-2 py-0.5 text-xs font-bold">
            <div className="flex items-center gap-1">
              <span>&#x1F0CF;</span>
              <span>Star Trek Solitaire</span>
            </div>
            <div className="flex gap-0.5">
              <button className="w-4 h-3.5 bg-[#c0c0c0] text-black text-[9px] flex items-center justify-center" style={{ border:'1px solid #fff', borderRight:'1px solid #404040', borderBottom:'1px solid #404040' }}>_</button>
              <button className="w-4 h-3.5 bg-[#c0c0c0] text-black text-[9px] flex items-center justify-center" style={{ border:'1px solid #fff', borderRight:'1px solid #404040', borderBottom:'1px solid #404040' }}>{'\u25a1'}</button>
              <button className="w-4 h-3.5 bg-[#c0c0c0] text-black text-[10px] flex items-center justify-center" style={{ border:'1px solid #fff', borderRight:'1px solid #404040', borderBottom:'1px solid #404040' }}>{'\u00d7'}</button>
            </div>
          </div>

          {/* Toolbar */}
          <div className="bg-[#c0c0c0] flex items-center gap-2 px-2 py-1 border-b border-[#808080]">
            <button onClick={handleNewGame} className="win95-btn bg-[#c0c0c0] px-3 py-0.5 text-[11px] cursor-pointer">New Game</button>
            <button onClick={handleUndo} disabled={history.length === 0} className="win95-btn bg-[#c0c0c0] px-3 py-0.5 text-[11px] cursor-pointer">Undo</button>
          </div>

          {/* Game Board */}
          <div className="win95-sunken m-1 p-3" style={{ background: '#1a472a' }}>

            {/* Top Row: Stock, Waste, Foundations */}
            <div className="flex justify-between mb-4">
              {/* Stock & Waste */}
              <div className="flex gap-3">
                {/* Stock */}
                <div
                  className="cursor-pointer"
                  data-pile-type="stock"
                  data-pile-index="0"
                  onClick={handleDraw}
                >
                  {game.stock.length > 0 ? (
                    <div className="relative" style={{ width: CARD_W, height: CARD_H }}>
                      <CardBack />
                      <div className="absolute bottom-1 right-1 bg-black/50 text-white text-[9px] px-1 rounded font-pixel">
                        {game.stock.length}
                      </div>
                    </div>
                  ) : (
                    <div
                      className="rounded-sm flex items-center justify-center"
                      style={{ width: CARD_W, height: CARD_H, border: '2px dashed rgba(255,255,255,0.2)', background: 'rgba(255,255,255,0.03)' }}
                    >
                      <span className="text-white/20 text-2xl">{'\u21BB'}</span>
                    </div>
                  )}
                </div>

                {/* Waste */}
                <div
                  className="relative"
                  data-pile-type="waste"
                  data-pile-index="0"
                  style={{ width: CARD_W + 40, height: CARD_H }}
                  onClick={() => handleEmptyClick('waste', 0)}
                >
                  {wasteVisible.length === 0 && <EmptySlot />}
                  {wasteVisible.map((card, i) => {
                    const offset = i * 20;
                    const isTop = i === wasteVisible.length - 1;
                    const realIdx = game.waste.length - wasteVisible.length + i;
                    const loc: PileLocation = { type: 'waste', index: 0, cardIndex: realIdx };
                    if (isTop) {
                      return renderCard(card, loc, { left: offset, top: 0 });
                    }
                    return (
                      <div key={card.id} className="absolute" style={{ left: offset, top: 0 }}>
                        <CardFace card={card} />
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Foundations */}
              <div className="flex gap-3">
                {game.foundations.map((foundation, fi) => (
                  <div
                    key={fi}
                    className="relative"
                    data-pile-type="foundation"
                    data-pile-index={fi}
                    style={{ width: CARD_W, height: CARD_H }}
                    onClick={() => handleEmptyClick('foundation', fi)}
                  >
                    {foundation.length === 0 ? (
                      <EmptySlot label={SUIT_SYMBOLS[SUITS[fi]]} highlight={selected !== null} />
                    ) : (
                      renderCard(
                        foundation[foundation.length - 1],
                        { type: 'foundation', index: fi, cardIndex: foundation.length - 1 },
                        { left: 0, top: 0 }
                      )
                    )}
                  </div>
                ))}
              </div>
            </div>

            {/* Tableau */}
            <div className="flex gap-3">
              {game.tableau.map((pile, ti) => {
                const pileH = pile.length === 0 ? CARD_H
                  : pile.reduce((acc, c, i) => acc + (i < pile.length - 1 ? (c.faceUp ? FUP_OFF : FDOWN_OFF) : CARD_H), 0);
                return (
                  <div
                    key={ti}
                    className="relative"
                    data-pile-type="tableau"
                    data-pile-index={ti}
                    style={{ width: CARD_W, minHeight: CARD_H, height: pileH }}
                    onClick={() => handleEmptyClick('tableau', ti)}
                  >
                    {pile.length === 0 && <EmptySlot highlight={selected !== null} />}
                    {pile.map((card, ci) => {
                      let top = 0;
                      for (let k = 0; k < ci; k++) {
                        top += pile[k].faceUp ? FUP_OFF : FDOWN_OFF;
                      }
                      const loc: PileLocation = { type: 'tableau', index: ti, cardIndex: ci };
                      return renderCard(card, loc, { left: 0, top });
                    })}
                  </div>
                );
              })}
            </div>
          </div>

          {/* Status Bar */}
          <div className="bg-[#c0c0c0] flex items-center text-[11px] border-t border-white">
            <div className="win95-sunken px-3 py-0.5 flex-1">Score: {game.score}</div>
            <div className="win95-sunken px-3 py-0.5 flex-1">Time: {formatTime(timer)}</div>
            <div className="win95-sunken px-3 py-0.5 flex-1">Moves: {game.moves}</div>
          </div>
        </div>
      </div>

      {/* Drag Layer */}
      {dragCards.length > 0 && (
        <div
          ref={dragLayerRef}
          className="fixed z-40 pointer-events-none"
          style={{ left: pointerStartRef.current.x, top: pointerStartRef.current.y }}
        >
          {dragCards.map((card, i) => (
            <div key={card.id} className="absolute drag-card" style={{ top: i * FUP_OFF, left: 0 }}>
              <CardFace card={card} />
            </div>
          ))}
        </div>
      )}

      {/* Victory */}
      {gameWon && <VictoryCascade onNewGame={handleNewGame} />}
    </>
  );
}

// ==================== RENDER ====================

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);

  </script>
</body>
</html>
